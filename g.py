import json
import requests
import sys
from pathlib import Path

# --- CONFIGURATION ---
API_KEY = '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'  # Replace with your actual key
API_URL = 'https://openrouter.ai/api/v1/responses'
MODEL = 'qwen/qwen3-8b'  # Example model, adjust as needed
OUTPUT_FILE = 'reasoning_results.json'

# --- DATA LOADING ---
def load_game_config(game_name):
    """Loads baseline constants for a game from config/config.json."""
    try:
        with open('config/config.json', 'r') as f:
            config = json.load(f)
        return config.get('game_configs', {}).get(game_name, {}).get('baseline', {})
    except FileNotFoundError:
        print("‚ö†Ô∏è config/config.json not found. Using defaults.")
        return {}

def get_filled_context(game_name):
    """Creates a sample context dictionary to fill the prompt variables."""
    cfg = load_game_config(game_name)
    
    # Default variables shared across some games
    context = {
        "player_id": "challenger", 
        "current_round": 1,
        "discount_factor": 0.9,
        **cfg # Merge in constants from JSON
    }

    # Add game-specific dynamic variables (usually generated by the engine)
    if game_name == 'salop':
        context.update({
            "number_of_players": 3,
            "circumference": 1.0,
            "distance_to_neighbor": 0.33,
            # Derived defaults if missing from config
            "market_size": context.get("market_size", 1000),
            "transport_cost": context.get("transport_cost", 1.5),
            "reservation_price": context.get("reservation_price", 30),
            "max_brand_utility": 40,
            "outside_good_surplus": 10,
            "marginal_cost": 8,
            "fixed_cost": 100
        })

    elif game_name == 'spulber':
        context.update({
            "number_of_competitors": 2, 
            "your_cost": 8,
            "rival_cost_distribution": "normal",
            "rival_cost_mean": 10,
            "rival_cost_std": 2.0,
            "demand_intercept": 100,
            "demand_slope": 1
        })

    elif game_name == 'green_porter':
        # Create a dummy history table for the test
        formatted_history = (
            "Period 1 | Collusive | $65.50\n"
            "Period 2 | Collusive | $66.00\n"
            "Period 3 | Price War | $64.80"
        )
        
        context.update({
            "number_of_players": 3,
            "current_market_state": "Collusive",
            "price_history": [65.5, 66.0, 64.8],
            "price_history_length": 3,
            "formatted_history_table": formatted_history,
            "collusive_quantity": 17,
            "cournot_quantity": 25,
            "trigger_price": 66,
            "punishment_duration": 2,
            "marginal_cost": 20,
            "base_demand": 120,
            "demand_slope": 1,
            "demand_shock_mean": 0,
            "demand_shock_std": 7,
            "demand_shock_distribution": "normal"
        })

    elif game_name == 'athey_bagwell':
        context.update({
            "number_of_players": 3,
            "your_cost_type": "low",
            "your_reports_history_detailed": "Period 1: low, Period 3: high",
            "all_other_reports_history_detailed": "Period 1: defender_1: low, defender_2: high; Period 3: defender_1: high, defender_2: high",
            "persistence_probability": 0.7,
            "market_size": 100,
            "market_price": 30
        })
        
    return context

# --- MAIN EXECUTION ---
games = ['salop', 'spulber', 'green_porter', 'athey_bagwell']
all_results = {}

print(f"üöÄ Starting reasoning tests for: {', '.join(games)}\n")

for game in games:
    print(f"{'='*40}")
    print(f"üéÆ Generating Reasoning for: {game.upper()}")
    print(f"{'='*40}")
    
    # 1. Read Prompt Template
    prompt_path = Path(f'prompts/{game}.md')
    if not prompt_path.exists():
        print(f"‚ùå Template not found at {prompt_path}")
        continue
        
    with open(prompt_path, 'r') as f:
        template = f.read()

    # 2. Fill Template
    try:
        context = get_filled_context(game)
        filled_prompt = template.format(**context)
    except KeyError as e:
        print(f"‚ùå Error filling variables: Missing {e}")
        continue

    # 3. Call OpenRouter
    print("‚è≥ Sending request to OpenRouter...")
    try:
        response = requests.post(
            API_URL,
            headers={
                'Authorization': f'Bearer {API_KEY}',
                'Content-Type': 'application/json',
            },
            json={
                'model': MODEL,
                'input': [
                    {
                        'type': 'message',
                        'role': 'user',
                        'content': [
                            {'type': 'input_text', 'text': filled_prompt},
                        ],
                    },
                ],
                'reasoning': {
                    'effort': 'high'
                },
                'max_output_tokens': 9000,
            }
        )
        
        if response.status_code == 200:
            result = response.json()
            print("‚úÖ Success! Response received.")
            
            # Store result with prompt context for debugging
            all_results[game] = {
                "prompt": filled_prompt,
                "api_response": result
            }
        else:
            print(f"‚ùå API Error {response.status_code}: {response.text}")
            all_results[game] = {
                "error": f"API Error {response.status_code}",
                "details": response.text
            }

    except Exception as e:
        print(f"‚ùå Request failed: {e}")
        all_results[game] = {"error": str(e)}

# --- SAVE RESULTS ---
print(f"\n{'='*40}")
try:
    with open(OUTPUT_FILE, 'w') as f:
        json.dump(all_results, f, indent=2)
    print(f"üíæ All reasoning results saved to: {OUTPUT_FILE}")
except Exception as e:
    print(f"‚ùå Failed to save output file: {e}")